
#include <math.h>

//sigma studio exported file
// put the path of the PARAM.h file generated by sigma studio
#include "/Users/Fabrice/Documents/VirtualBox VMs/generic2x4v3_IC_1_PARAM.h"

//verify each of the defines below in accordance with the sigmastudio generic file syntax you adopted
#define DEF_FILTER_ADDR(x)    defined( MOD_FILTER##x##_ALG0_STAGE0_B2_ADDR )
#define DSP_FILTER_ADDR(x)    MOD_FILTER##x##_ALG0_STAGE0_B2_ADDR
#define DEF_FILTER_COUNT(x)   defined( MOD_FILTER##x##_COUNT )
#define DSP_FILTER_COUNT(x)   MOD_FILTER##x##_COUNT

#define DEF_FIR_ADDR(x)       defined( MOD_FIR##x##_ALG0_FIRSIGMA300ALG1FIRCOEFF0_ADDR )
#define DSP_FIR_ADDR(x)       MOD_FIR##x##_ALG0_FIRSIGMA300ALG1FIRCOEFF0_ADDR
#define DEF_FIR_COUNT(x)      defined( MOD_FIR##x##_COUNT )
#define DSP_FIR_COUNT(x)      MOD_FIR##x##_COUNT

#define DSP_GAIN_IN_ADDR      MOD_GAIN_IN_ALG0_GAIN0_ADDR
#define DSP_GAIN_IN_COUNT     MOD_GAIN_IN_COUNT
#define DSP_GAIN_OUT_ADDR     MOD_GAIN_OUT_ALG0_GAIN0_ADDR
#define DSP_GAIN_OUT_COUNT    MOD_GAIN_OUT_COUNT

#define DEF_RMS_ADDR(x)       defined( MOD_RMS##x##_ALG0_SINGLEBANDLEVELREADS3007LEVEL_ADDR )
#define DSP_RMS_ADDR(x)       MOD_RMS##x##_ALG0_SINGLEBANDLEVELREADS3007LEVEL_ADDR

#define DEF_MIXER_IN(x)       defined( MOD_MIXER_IN_ALG0_NXNMIXALG2VOL0##x##00_ADDR )
#define DSP_MIXER_IN_ADDR(x)  MOD_MIXER_IN_ALG0_NXNMIXALG2VOL0##x##00_ADDR
#define DEF_MIXER_OUT(x)      defined( MOD_MIXER_OUT_ALG0_NXNMIXALG1VOL0##x##00_ADDR )
#define DSP_MIXER_OUT_ADDR(x) MOD_MIXER_OUT_ALG0_NXNMIXALG1VOL0##x##00_ADDR

#define DSP_DELAY_OUT_ADDR    MOD_DELAY_OUT_ALG0_DELAYAMT_ADDR
#define DSP_DELAY_OUT_COUNT   MOD_DELAY_OUT_COUNT
#define DSP_DELAY_OUT_MAX     (600) // samples

//////////////////////////////////////////////////////////////////////////////////////////

#define DSP_INPUTS  DSP_GAIN_IN_COUNT
#define DSP_OUTPUTS DSP_GAIN_OUT_COUNT

// total number of filter bank, including both Inputs and Outputs
#define DSP_IO_TOTAL (DSP_INPUTS + DSP_OUTPUTS)


#if DEF_FILTER_COUNT(1)
#define FILTER1_COUNT DSP_FILTER_COUNT(1)
#else
#error no filter defined. Expecting filter block with name "FILTERx" with x starting 1
#endif
#if DEF_FILTER_COUNT(2) && (DSP_FILTER_COUNT(2) > FILTER1_COUNT)
#define FILTER2_COUNT DSP_FILTER_COUNT(2)
#else
#define FILTER2_COUNT FILTER1_COUNT
#endif
#if DEF_FILTER_COUNT(3) && (DSP_FILTER_COUNT(3) > FILTER2_COUNT)
#define FILTER3_COUNT DSP_FILTER_COUNT(3)
#else
#define FILTER3_COUNT FILTER2_COUNT
#endif
#if DEF_FILTER_COUNT(4) && (DSP_FILTER_COUNT(4) > FILTER3_COUNT)
#define FILTER4_COUNT DSP_FILTER_COUNT(4)
#else
#define FILTER4_COUNT FILTER3_COUNT
#endif
#if DEF_FILTER_COUNT(5) && (DSP_FILTER_COUNT(5) > FILTER4_COUNT)
#define FILTER5_COUNT DSP_FILTER_COUNT(5)
#else
#define FILTER5_COUNT FILTER4_COUNT
#endif
#if DEF_FILTER_COUNT(6) && (DSP_FILTER_COUNT(6) > FILTER5_COUNT)
#define FILTER6_COUNT DSP_FILTER_COUNT(6)
#else
#define FILTER6_COUNT FILTER5_COUNT
#endif
#if DEF_FILTER_COUNT(7) && (MOD_FILTER7_COUNT > FILTER6_COUNT)
#define FILTER7_COUNT DSP_FILTER_COUNT(7)
#else
#define FILTER7_COUNT FILTER6_COUNT
#endif
#if DEF_FILTER_COUNT(8) && (DSP_FILTER_COUNT(8) > FILTER7_COUNT)
#define FILTER8_COUNT DSP_FILTER_COUNT(8)
#else
#define FILTER8_COUNT FILTER7_COUNT
#endif
#if DEF_FILTER_COUNT(9) && (DSP_FILTER_COUNT(9) > FILTER8_COUNT)
#define FILTER9_COUNT DSP_FILTER_COUNT(9)
#else
#define FILTER9_COUNT FILTER8_COUNT
#endif
#if DEF_FILTER_COUNT(10) && (DSP_FILTER_COUNT(10) > FILTER9_COUNT)
#define FILTER10_COUNT DSP_FILTER_COUNT(10)
#else
#define FILTER10_COUNT FILTER9_COUNT
#endif
#if DEF_FILTER_COUNT(11) && (DSP_FILTER_COUNT(11) > FILTER10_COUNT)
#define FILTER11_COUNT DSP_FILTER_COUNT(11)
#else
#define FILTER11_COUNT FILTER10_COUNT
#endif
#if DEF_FILTER_COUNT(12) && (DSP_FILTER_COUNT(12) > FILTER11_COUNT)
#define FILTER12_COUNT DSP_FILTER_COUNT(12)
#else
#define FILTER12_COUNT FILTER11_COUNT
#endif
#if DEF_FILTER_COUNT(13) && (DSP_FILTER_COUNT(13) > FILTER12_COUNT)
#define FILTER13_COUNT DSP_FILTER_COUNT(13)
#else
#define FILTER13_COUNT FILTER12_COUNT
#endif
#if DEF_FILTER_COUNT(14) && (DSP_FILTER_COUNT(14) > FILTER13_COUNT)
#define FILTER14_COUNT DSP_FILTER_COUNT(14)
#else
#define FILTER14_COUNT FILTER13_COUNT
#endif
#if DEF_FILTER_COUNT(15) && (DSP_FILTER_COUNT(15) > FILTER14_COUNT)
#define FILTER15_COUNT DSP_FILTER_COUNT(15)
#else
#define FILTER15_COUNT FILTER14_COUNT
#endif
#if DEF_FILTER_COUNT(16) && (DSP_FILTER_COUNT(16) > FILTER15_COUNT)
#define FILTER16_COUNT DSP_FILTER_COUNT(16)
#else
#define FILTER16_COUNT FILTER15_COUNT
#endif

// this define the maximum number of successive biquad seen in the generic sigmastudio file
#define FILTER_BANK_SIZE (FILTER16_COUNT / 5)

#if DEF_RMS_ADDR(1)
extern const dsp32_t rmsAddr[8];
#endif

typedef float dspFloat_t;
typedef float dspFilterParam_t; // 32bits IEEE754
typedef float dspGainParam_t;
typedef int   dsp32_t;


#if 0
//below structure using bitfield is not used in this version
typedef struct {
    int mantissa:24;
    int integer:8;
} dsp824_t;
_Static_assert(sizeof(dsp824_t)==4,"dsp8_24_t is not packed as 32bits by this compiler");
#else
typedef int dsp824_t;
#endif


// the list of all supported filters.
enum filterTypes { FNONE,
        BEna1,LPBE2,LPBE3,LPBE4,BEna5,LPBE6,BEna9,LPBE8,   // bessel
        BEna2,HPBE2,HPBE3,HPBE4,BEna6,HPBE6,BEna10,HPBE8,
        BEna3,LPBE3db2,LPBE3db3,LPBE3db4,BEna7,LPBE3db6,BEna11,LPBE3db8,    // bessel at -3db cutoff
        BEna4,HPBE3db2,HPBE3db3,HPBE3db4,BEna8,HPBE3db6,BEna12,HPBE3db8,
        BUna1,LPBU2,LPBU3,LPBU4,BUna3,LPBU6,BUna5,LPBU8, // buterworth
        BUna2,HPBU2,HPBU3,HPBU4,BUna4,HPBU6,BUna6,HPBU8,
        Fna1,LPLR2,LPLR3,LPLR4,Fna3,LPLR6,Fna4,LPLR8,   // linkwitz rilley
        Fna5,HPLR2,HPLR3,HPLR4,Fna7,HPLR6,Fna8,HPLR8,
        FLP1,FLP2,FHP1,FHP2,FAP1,FAP2,FBP0DB, FBPQ,
        FLS1,FLS2,FHS1,FHS2,FPEAK,FNOTCH,         // other shelving, allpass, peaking, notch, bandpass
};


// each user filter definition will be stored in this structure
typedef struct  {    // basic structure requires 16 bytes per user defined filter
    enum filterTypes ftype;         // this is a binary number based on "enum filterTypes" above
    char bypass;                    // 0 : normal  , 1 : not used/bypassed
    char invert;                    // 1 : invert phase by applying negative gain
    char locked;                    // 1 to indicate that the filter should not be changed
    dspFloat_t freq;                // corner frequency of the filter
    dspFloat_t Q;                   // quality factor of the filter (if relevant)
    dspFloat_t gain;                // boost gain for this filter
} dspFilter_t;

// each input or output is associated with a filter bank and gain delay like this
typedef struct {
    dspFloat_t   mixer[DSP_INPUTS];             // gain coefficient for mixing each relevant input
    int          numberOfFilters;               // number of filters supported in this bank according to sigma studio generic file loaded
    dspFilter_t  filter[FILTER_BANK_SIZE];      // table containing the list of filters
    dspFloat_t   gain;                          // gain attached with this filter bank (upfront for input, otherwise after for output)
    dspFloat_t   delayMicroSec;                 // delay added at the end of the filter bank in micro seconds
    int mute;                                   // 1 if muted
    int invert;                                 // 1 if inverted
} dspFilterBlock_t;


// structure defining a full preset containing mixers, gains, filter and delay for all the inputs & outputs
typedef struct  {
    int presetNumber;               // index of the preset as seen by user
    int checksum;                   // checksum of all the data stored in the preset
    int filterBankSize;             // same as FILTER_BANK_SIZE : maximum number of filters seen for all banks
    int numberOfInputs;             // number of input channels stored in the preset
    int numberOfOutputs;            // number of output channels stored in the preset
    dspFilterBlock_t fb[DSP_IO_TOTAL];   // a table of filter block defined in the structure above
} dspPreset_t;

// basic structure for holding the biquad coefficient computed for a given sampling rate
typedef struct {
    dspFloat_t b0;
    dspFloat_t b1;
    dspFloat_t b2;
    dspFloat_t a1;
    dspFloat_t a2;
} dspBiquadCoefs_t;

//same structure but as 8.24 integer, compatible with sigmadsp > ADAU1452 (not 1701)
typedef struct {
    dsp824_t b0;
    dsp824_t b1;
    dsp824_t b2;
    dsp824_t a1;
    dsp824_t a2;
} dspBiquadCoefs824_t;

// basic structure for Complex number
typedef struct {
    float re;
    float im;
} dspComplex_t;

// structure for managing filter response and bode plot
typedef struct {
    float freq;
    dspComplex_t Z; // frequency/fs in complex domain
    dspComplex_t H; // response
    float mag;      // magnitude in dB for the bode Plot
    float phase;    // phase for bode plot
} dspBode_t;

// buffer required to download a filter bank configuration to the sigmadsp param memory
#define DSP_PARAM_BUFFER_SIZE (2+DSP_INPUTS  +2 +2 +2+FILTER_BANK_SIZE*sizeof(dspBiquadCoefs824_t) + 1)

typedef dsp32_t sigmadspBuffer_t[DSP_PARAM_BUFFER_SIZE];

#if 0
// convert a deciBell value to a float number. e.g. dB2gain(10.0) => 3.162277
// expected to be optimized by compiler where dB is known at compile time
static inline dspFloat_t dB2gain(dspFloat_t db){
    db /= 20.0;
    return pow(10,db); }
#endif

// convert a float number to a fixed point integer with a mantissa of 24 bit
// eg : the value 0.5 will be coded as 0x00800000
static inline dsp824_t dspQ8_24(float f){
    float maxf = (1 << 7);
    if (f >=   maxf)  return 0x7fffffff;
    if (f < (-maxf))  return -1;
    unsigned mul = 1 << 24;
    f *= mul;
    return f;   // will convert to integer
}

// this macro makes life easier to go trough each of the filter banks , including inputs & outputs
#define DSP_FOR_ALL_CHANNELS(p,ch) for (int ch=0; ch < (p->numberOfInputs + p->numberOfOutputs); ch++)

extern const int filterBankSize[16];
extern const char * dspFilterNames[];   // short comprehensive name for the filter ftype, 5 char max
extern const char   dspFilterCells[];   // number of biquad cells needed for the filter ftype (1..4) 0 for fnone
extern const dspFilter_t dspFilterNone; // default content for fnone filter

enum filterTypes dspFilterNameSearch(char *s);
// return the checksum of a preset
extern int  dspPresetChecksum(dspPreset_t * p);
// calculate and then update the checksum of a preset (typically used before saving)
extern void dspPresetChecksumUpdate(dspPreset_t * p);
// calculate and then verify the checksum of a preset (typically used after loading a preset)
extern int  dspPresetChecksumVerify(dspPreset_t * p);
// reset a preset with defaut mixer, gain, delay and fnone in each filter bank
extern void dspPresetReset(dspPreset_t * p, int numPreset);
// prepare the data and biquad for downloading to sigmadsp, for a given channel within a given preset
extern int  dspPresetConvert(dspPreset_t * p, int channel, dsp32_t * dest, dspFloat_t fs, dspFloat_t gainMul, dspFloat_t delayAdd);
// set a filter in the bank of a given channel of a given preset
extern void dspPresetSetFilter(dspPreset_t * p, int channel, int numFilter, dspFilter_t filter);
extern int dspFilterNeedQ(enum filterTypes ftype);
extern int dspFilterNeedGain(enum filterTypes ftype);
// compute the number of biquad cells needed for the filter bank associated to a given channel of a given preset
extern int  dspPresetCalcCellsUsed(dspPreset_t * p, int ch);
// return a comprehensive table indicating how the biquad cells available are fulfilled with the filters.
extern int  dspPresetCalcTableCellsUsed(dspPreset_t * p, int ch, char * table);
// go through the list of filters and ensure that any FNONE is at the end of the list
extern void dspPresetMoveNoneFilters(dspPreset_t * p, int channel);
//sort the filters by increasing frequencies. Move the FNONE filters at the end
extern void dspPresetSortFilters(dspPreset_t * p, int channel);

// calculate the multiplier for producing a geometrical list of frequencies between start-stop
extern float dspFreqMultiplier(dspFloat_t start, dspFloat_t stop, int N);
// initialize the table containing the response for further printing as a bode plot
extern void dspBodeResponseInit(dspBode_t * t, int N, dspFloat_t gain);
// initialize the table of frequencies with the geometrical list between start and stop
extern void dspBodeFreqInit(dspFloat_t start, dspFloat_t stop, int round, dspBode_t * t, int N, dspFloat_t fs);
// apply a biquad on the response table to further print as a bode plot
extern void dspBodeApplyBiquad(dspBode_t * t, int N, dspBiquadCoefs_t * bq);
// apply a filter made of multiple biquad on the response table
extern void dspBodeApplyFilter(dspBode_t * t, int N, dspFilter_t * f);
// apply all the bank filter on the response table
extern void dspBodeApplyFilterBank(dspBode_t * t, int N, dspFilterBlock_t * fb);
// compute the magnitude of the response in deciBell. return also min and max
extern void dspBodeMagnitudeDB(dspBode_t * t, int N, dspFloat_t gain, dspFloat_t *min, dspFloat_t *max);
// compute the phase of the response, in degrees between -180..+180
extern void dspBodePhase(dspBode_t * t, int N);
